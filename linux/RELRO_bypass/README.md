README
======

#### CHEATSHEET:
`$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`

`-Wl,-z,relro # partial relro`

`-Wl,-z,relro,-z,now # full relro`

`$ gcc relro_bypass.c -o relro_bypass -fstack-protector-all -Wl,-z,relro -no-pie -m32`

`gdb-peda$ set disable-randomization on`


#### VULNERABLE CODE:
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char **argv)
{
   char *pointer[4];
   char second[4];

   strncpy(pointer, argv[1], 4);
   printf("Ptr points to %p\n", *pointer);

   printf("Now we will copy the argv[2]: %s to the location: %p\n", argv[2], *pointer);

   strncpy(*pointer, argv[2], 4);
   printf("sh");

   return EXIT_SUCCESS;
}
```
# NO RELRO
Before explaining relro  let's type down how an ELF binary without RELRO works.
A binary uses the Global Offset Table (GOT) to resolve the functions of the shared libraries. Resolve the functions means finding their address in memory during [functions call]\*. **GOT is populated dinamically as the program is running**.

## Procedure Linkage Table (PLT) and Global Offset Table (GOT)
The process of resolving the function address is:

1. A [function call]\* instruction points to an address into the .plt section
2. The address into the .plt points then to a function address in GOT (.got.plt section)
3. **The first time** a function is called GOT points back to .plt where the final address of the called function is stored.
4. **The second/third/n time** a function is called GOT already contains the known location of the called function (lazy binding to save CPU cycles).

To allow lazy binding GOT needs to be writable.

**GOT exists at a predefined place in memory, a program that contains a vulnerability allowing an attacker to write 4 bytes at a controlled place in memory(GOT) may be exploited to allow arbitrary code execution.**


# Full RELRO
To avoid the possibility to write those 4 bytes in memory **Full RELRO** makes the linker load all the symbols before the programs execution (before calling the main function) populating the GOT (.got and .got.plt) and making it read only. At this point GOT contains everything it needs to resolve the function calls, so there is no reason to leave it writable.

To summarize:

* The linker will perform **ALL** the symbol lookup before the execution starts and then will remove the write permissions from .got.
* got.plt becomes part of .got
* Exploitation by overwriting .got entries is not possible. There are other unconventional, creatives way. (TBD)
* Full RELRO is not a default compiler setting as it can greatly increase program startup time since all symbols must be resolved before the program is started. In large programs with thousands of symbols that need to be linked, this could cause a noticable delay in startup time.


# Partial RELRO 
In partial RELRO, the non-PLT part of the GOT section (.got) is read only but .got.plt is still writable because the linker will resolve **ONLY** the functions that will be used at runtime; this means that lazy binding is still available and that's why .got.plt remains writable. Writable = exploitation is still possible.

To summarize:

* The linker will perform the symbol lookup **ONLY** on the symbols which are going to be used and it will resolve only the functions that will be used at runtime so .got.plt will be writable.
* Forces the GOT to come before the BSS* in memory, eliminating the risk of a buffer overflows on a global variable overwriting GOT entries.
* maps a .got section as read only while .got.plt is writable. 
* Exploitation is still possibile.

\*BSS segment contains all global variables and static variables that are initialized to zero or do not have explicit initialization in source code. For instance, a variable defined as static int i; would be contained in the BSS segment.

## Exploitation of Partial RELRO
//TBD














